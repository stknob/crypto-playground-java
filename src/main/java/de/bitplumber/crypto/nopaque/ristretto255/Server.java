package de.bitplumber.crypto.nopaque.ristretto255;

import java.nio.charset.StandardCharsets;
import java.util.Objects;

import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.RandomUtils;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Bytes;

import de.bitplumber.crypto.nopaque.CredentialIdentifier;
import de.bitplumber.crypto.nopaque.Labels;
import de.bitplumber.crypto.oprf.KeyPair;

/**
 * Server implementation of NOPAQUE-Ristretto255-SHA512
 */
public class Server extends AbstractRistretto255 {
	private final ServerParameter params;

	public Server() {
		this.params = new ServerParameter();
	}

	public Server(ServerParameter params) {
		this.params = params;
	}

	public static final ServerParameter DEFAULT_PARAMETER = new ServerParameter()
		.withCustomDeriveKeypairLabel(Labels.NOPAQUE_DERIVE_KEYPAIR);

	public static final class ServerParameter {
		protected byte[] customDeriveKeypairLabel;
		protected byte[] maskingNonce;

		public byte[] customDeriveKeypairLabel() {
			return customDeriveKeypairLabel;
		}

		public byte[] maskingNonce() {
			return maskingNonce;
		}

		/**
		 * Set a custom domain separation label for key derivation
		 * <strong>For unittests only!</strong>
		 * @param label
		 * @return
		 */
		public ServerParameter withCustomDeriveKeypairLabel(byte[] label) {
			Objects.requireNonNull(label, "label");
			this.customDeriveKeypairLabel = label;
			return this;
		}

		/**
		 * Set a custom domain separation label for key derivation
		 * <strong>For unittests only!</strong>
		 * @param label
		 * @return
		 */
		public ServerParameter withCustomDeriveKeypairLabel(String label) {
			Objects.requireNonNull(label, "label");
			this.customDeriveKeypairLabel = label.getBytes(StandardCharsets.UTF_8);
			return this;
		}

		/**
		 * Set a custom domain separation label for key derivation
		 * <strong>For unittests only!</strong>
		 * @param maskingNonce
		 * @return
		 */
		public ServerParameter withMaskingNonce(byte[] maskingNonce) {
			Objects.requireNonNull(maskingNonce, "maskingNonce");
			this.maskingNonce = maskingNonce;
			return this;
		}
	}

	/**
	 * Server - Generate random OPRF seed
	 * @return
	 */
	public byte[] randomSeed() {
		return RandomUtils.secureStrong().randomBytes(N_SEED);
	}

	/**
	 * Server - Generate a random keypair
	 * @return
	 */
	public KeyPair randomKeyPair() {
		return oprf.randomKeyPair();
	}

	/**
	 * Server - Create an answer to a client's <code>RegistrationRequest</code>
	 * @param regRequest The <code>RegistrationRequest</code> sent by the client
	 * @param serverPublicKey The server's OPRF public key (either from a shared or per-credential keypair)
	 * @param credentialIdentifier The <code>CredentialIdentifier</code> assigned to the client
	 * @param oprfSeed The per-credential OPRF seed value, generated by <code>randomSeed()</code>
	 * @return <code>RegistrationResponse</code> to be sent to the client
	 * @throws Exception
	 */
	public RegistrationResponse createRegistrationResponse(RegistrationRequest regRequest, byte[] serverPublicKey, CredentialIdentifier credentialIdentifier, byte[] oprfSeed) throws Exception {
		final var seed = expand(oprfSeed, Arrays.concatenate(credentialIdentifier.toByteArray(), Labels.OPRF_KEY), N_OK);
		final var serverKeyPair = oprf.deriveKeyPair(seed, ObjectUtils.defaultIfNull(params.customDeriveKeypairLabel(), Labels.NOPAQUE_DERIVE_KEYPAIR));

		final var blindedElement = oprf.decodeElement(regRequest.blindedElement());
		final var evaluatedElement = oprf.blindEvaluate(serverKeyPair.secretKey(), blindedElement);
		final var evaluatedMessage = oprf.encodeElement(evaluatedElement);
		return new RegistrationResponse(evaluatedMessage, serverPublicKey);
	}

	/**
	 * Server-only: Client registration information for longterm storage in a database etc.
	 */
	public static final record RegistrationRecord(byte[] clientPublicKey, byte[] maskingKey, byte[] envelopeNonce, byte[] authTag) {
		public static RegistrationRecord fromBytes(byte[] input) {
			final var clientPublicKey = Arrays.copyOfRange(input, 0, N_PK);
			final var maskingKey = Arrays.copyOfRange(input, N_PK, N_PK + N_H);
			final var envelopeNonce = Arrays.copyOfRange(input, N_PK + N_H, N_PK + N_H + N_N);
			final var authTag = Arrays.copyOfRange(input, N_PK + N_H + N_N, input.length);
			return new RegistrationRecord(clientPublicKey, maskingKey, envelopeNonce, authTag);
		}

		public byte[] toByteArray() {
			return Arrays.concatenate(clientPublicKey, maskingKey, envelopeNonce, authTag);
		}
	}

	/**
	 * Server: Generate an answer to a client's <code>RecoverRequest</code> using information from longterm storage
	 * @param serverKeypair The OPRF keypair of the server (either shared by all credentials, or per-credential)
	 * @param regRecord <code>RegistrationRecord</code> associated with the given <code>credentialIdentifier</code>, from the server's longterm storage
	 * @param credentialIdentifier
	 * @param oprfSeed The OPRF seed associated with the given <code>RegistrationRecord</code> / <code>credentialIdentifier</code>
	 * @param ke1 The <code>RecoverRequest</code> sent by the client
	 * @return <code>RecoverResponse</code> to be sent to the client to finish the recover process
	 * @throws Exception
	 */
	public RecoverResponse createRecoverResponse(KeyPair serverKeypair, RegistrationRecord regRecord, CredentialIdentifier credentialIdentifier, byte[] oprfSeed, RecoverRequest ke1) throws Exception {
		final var seed = expand(oprfSeed, Arrays.concatenate(credentialIdentifier.toByteArray(), Labels.OPRF_KEY), N_OK);
		final var oprfKey = oprf.deriveKeyPair(seed, ObjectUtils.defaultIfNull(params.customDeriveKeypairLabel(), Labels.NOPAQUE_DERIVE_KEYPAIR)).secretKey();

		final var blindedElement = oprf.decodeElement(ke1.blindedMessage());
		final var evaluatedElement = oprf.blindEvaluate(oprfKey, blindedElement);
		final var evaluatedMessage = oprf.encodeElement(evaluatedElement);

		final var maskingNonce = ObjectUtils.defaultIfNull(params.maskingNonce(), RandomUtils.secureStrong().randomBytes(N_N));
		final var credentialResponsePad = expand(regRecord.maskingKey(), Arrays.concatenate(maskingNonce, Labels.CREDENTIAL_RESPONSE_PAD), N_PK + N_N + N_M);
		final var unmaskedResponse = new MaskedResponse(serverKeypair.publicKey(), regRecord.envelopeNonce(), regRecord.authTag()).toByteArray();

		final var maskedResponse = new byte[credentialResponsePad.length];
		Bytes.xor(unmaskedResponse.length, credentialResponsePad, unmaskedResponse, maskedResponse);
		return new RecoverResponse(evaluatedMessage, maskingNonce, maskedResponse);
	}
}
